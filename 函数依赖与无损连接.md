在关系型数据库中，**分解关系模式**是规范化设计的重要步骤。分解后的关系模式需要满足两个关键性质：
1. **保持函数依赖**：分解后的关系模式能够保留原始关系模式中的所有函数依赖。
2. **无损连接**：分解后的关系模式能够通过自然连接操作恢复原始关系模式，且不丢失任何信息。

以下是通俗易懂的解释和判断方法：

---

### **1. 保持函数依赖**
#### **什么是保持函数依赖？**
- 分解后的关系模式能够**保留原始关系模式中的所有函数依赖**。
- 如果某些函数依赖在分解后无法通过某个关系模式推导出来，则分解不保持函数依赖。

#### **判断方法**
1. **列出原始函数依赖集**：
   - 假设原始关系模式 `R` 的函数依赖集为 `F`。
2. **分解后的关系模式**：
   - 假设分解后的关系模式为 `R1, R2, ..., Rn`。
3. **计算每个关系模式的函数依赖集**：
   - 对于每个 `Ri`，计算其函数依赖集 `Fi`，即 `F` 在 `Ri` 上的投影。
4. **检查是否覆盖所有函数依赖**：
   - 检查 `F` 中的所有函数依赖是否可以通过 `F1 ∪ F2 ∪ ... ∪ Fn` 推导出来。
   - 如果所有函数依赖都能被覆盖，则分解保持函数依赖；否则不保持。

#### **示例**
假设原始关系模式 `R` 的属性集合为 `U = {A, B, C}`，函数依赖集为 `F = {A → B, B → C}`。

- **分解 1**：`R1 = {A, B}`，`R2 = {B, C}`。
  - `R1` 的函数依赖集：`F1 = {A → B}`。
  - `R2` 的函数依赖集：`F2 = {B → C}`。
  - `F1 ∪ F2 = {A → B, B → C}`，覆盖了 `F` 中的所有函数依赖。
  - 因此，分解保持函数依赖。

- **分解 2**：`R1 = {A, B}`，`R2 = {A, C}`。
  - `R1` 的函数依赖集：`F1 = {A → B}`。
  - `R2` 的函数依赖集：`F2 = {}`（因为 `A → C` 不在 `F` 中）。
  - `F1 ∪ F2 = {A → B}`，无法覆盖 `B → C`。
  - 因此，分解不保持函数依赖。

---

### **2. 无损连接**
#### **什么是无损连接？**
- 分解后的关系模式能够通过**自然连接操作**恢复原始关系模式，且不丢失任何信息。
- 如果连接后的结果与原始关系模式一致，则分解是无损连接的；否则是有损连接的。

#### **判断方法**
1. **使用 Chase 算法**：
   - 构造一个表格，表示分解后的关系模式。
   - 通过应用函数依赖，填充表格中的符号。
   - 如果表格中有一行完全填充为原始关系模式的符号，则分解是无损连接的。

2. **简单判断法**：
   - 如果分解后的关系模式中，至少有一个关系模式包含原始关系模式的候选键，则分解是无损连接的。

#### **示例**
假设原始关系模式 `R` 的属性集合为 `U = {A, B, C}`，函数依赖集为 `F = {A → B, B → C}`。

- **分解 1**：`R1 = {A, B}`，`R2 = {B, C}`。
  - `R1` 包含候选键 `{A}`。
  - 因此，分解是无损连接的。

- **分解 2**：`R1 = {A, B}`，`R2 = {A, C}`。
  - `R1` 包含候选键 `{A}`。
  - 因此，分解是无损连接的。

- **分解 3**：`R1 = {A, B}`，`R2 = {C}`。
  - `R1` 包含候选键 `{A}`。
  - 因此，分解是无损连接的。

---

### **3. 总结**
- **保持函数依赖**：分解后的关系模式能够保留原始关系模式中的所有函数依赖。
- **无损连接**：分解后的关系模式能够通过自然连接操作恢复原始关系模式，且不丢失任何信息。
- **判断方法**：
  - 保持函数依赖：检查分解后的函数依赖集是否覆盖原始函数依赖集。
  - 无损连接：使用 Chase 算法或简单判断法（是否包含候选键）。

通过以上方法，可以判断分解后的关系模式是否满足保持函数依赖和无损连接的要求。