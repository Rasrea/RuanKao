在设计模式中，虽然有些模式看起来相似，但它们的应用场景和目的不同。下面是 **创建型、结构型、行为型**
设计模式的区分方法，并附带简单的示例，以帮助你快速理解它们的不同之处！🚀

---

## **1️⃣ 创建型模式（Creational Patterns）**

**👉 关注如何创建对象，使代码更灵活、更可扩展。**

| 模式                         | 主要作用          | 关键特征                      | 适用场景                         |
|----------------------------|---------------|---------------------------|------------------------------|
| **抽象工厂（Abstract Factory）** | 创建**一组**相关对象  | 多个工厂方法，返回不同但相关的对象         | 需要创建**一组**相关对象（如 UI 组件）      |
| **工厂方法（Factory Method）**   | 让子类决定创建哪种对象   | 通过子类重写工厂方法                | 不同子类生产不同对象，避免直接 `new`        |
| **生成器（Builder）**           | 复杂对象的**逐步构造** | **一步步创建对象**，最后返回          | 需要灵活构建复杂对象，如 `StringBuilder` |
| **原型（Prototype）**          | **克隆**已有对象    | 通过 `clone()` 复制           | 创建代价高，想要**拷贝**而不是 `new`      |
| **单例（Singleton）**          | **确保全局唯一**的实例 | 只有一个实例，`getInstance()` 访问 | **共享资源**（如数据库连接池、线程池）        |

🔹 **示例对比**

```java
// 🔹 工厂方法
abstract class Factory {
    abstract Product createProduct();
}

class ConcreteFactory extends Factory {
    Product createProduct() {
        return new ConcreteProduct();
    }
}

// 🔹 抽象工厂（创建一组对象）
interface GUIFactory {
    Button createButton();

    Window createWindow();
}

class WinFactory implements GUIFactory {
    Button createButton() {
        return new WinButton();
    }
}

// 🔹 生成器
class CarBuilder {
    void setEngine(String e) {
    }

    void setWheels(int w) {
    }

    Car build() {
    }
}

// 🔹 单例
class Singleton {
    private static Singleton instance;

    public static Singleton getInstance() {
        if (instance == null) instance = new Singleton();
        return instance;
    }
}

// 🔹 原型
class Prototype implements Cloneable {
    public Prototype clone() throws CloneNotSupportedException {
        return (Prototype) super.clone();
    }
}
```

---

## **2️⃣ 结构型模式（Structural Patterns）**

**👉 关注如何组织对象和类，形成更大的结构。**

| 模式                | 主要作用           | 关键特征            | 适用场景                            |
|-------------------|----------------|-----------------|---------------------------------|
| **适配器（Adapter）**  | 让两个不兼容的接口协同工作  | `Adapter` 转换接口  | **接口不匹配**但需要一起用（如 Type-C 转 USB） |
| **桥接（Bridge）**    | **解耦**抽象与实现    | 两层抽象，桥接接口       | 需要**多个维度变化**（如形状+颜色）            |
| **组合（Composite）** | 统一**树形结构**访问方式 | 叶子和容器**统一接口**   | 需要**递归结构**（如文件夹）                |
| **装饰（Decorator）** | **动态扩展功能**     | 递归包装            | 运行时**增强对象功能**（如 Java I/O）       |
| **享元（Flyweight）** | **共享**相似对象     | 复用**相同实例**，减少内存 | 需要**缓存可复用对象**（如字符对象池）           |
| **代理（Proxy）**     | 控制**对象访问**     | 代理类控制对象访问       | **权限控制、远程代理**（如 RPC 代理）         |

🔹 **示例对比**

```java
// 🔹 适配器（转换接口）
class OldSystem {
    void oldMethod() {
    }
}

class Adapter extends OldSystem {
    void newMethod() {
        oldMethod();
    }
}

// 🔹 桥接（两个抽象层）
interface Color {
    String getColor();
}

class Red implements Color {
    public String getColor() {
        return "Red";
    }
}

abstract class Shape {
    protected Color color;

    Shape(Color color) {
        this.color = color;
    }

    abstract void draw();
}

class Circle extends Shape {
    void draw() {
        System.out.println("Circle in " + color.getColor());
    }
}

// 🔹 组合（树结构）
interface Component {
    void render();
}

class Leaf implements Component {
    void render() {
        System.out.println("Leaf");
    }
}

class Composite implements Component {
    List<Component> children = new ArrayList<>();

    void render() {
        for (Component c : children) c.render();
    }
}

// 🔹 装饰器（增强功能）
interface Coffee {
    String getDescription();
}

class BasicCoffee implements Coffee {
    public String getDescription() {
        return "Coffee";
    }
}

class SugarDecorator implements Coffee {
    Coffee coffee;

    SugarDecorator(Coffee c) {
        this.coffee = c;
    }

    public String getDescription() {
        return coffee.getDescription() + " + Sugar";
    }
}

// 🔹 代理（控制访问）
interface Service {
    void request();
}

class RealService implements Service {
    public void request() {
        System.out.println("Request handled.");
    }
}

class ProxyService implements Service {
    RealService realService = new RealService();

    public void request() {
        System.out.println("Logging...");
        realService.request();
    }
}
```

---

## **3️⃣ 行为型模式（Behavioral Patterns）**

**👉 关注对象如何交互，分配职责。**

| 模式                               | 主要作用             | 关键特征                | 适用场景                      |
|----------------------------------|------------------|---------------------|---------------------------|
| **责任链（Chain of Responsibility）** | **多个处理者** 依次处理请求 | `next.handle()`     | 请求需要被**多个对象**处理（如日志级别）    |
| **命令（Command）**                  | **封装请求**，解耦调用者   | `execute()`         | 需要**撤销/重做**（如按钮撤销操作）      |
| **观察者（Observer）**                | **发布-订阅模式**      | `notifyObservers()` | **事件驱动**（如监听按钮点击）         |
| **策略（Strategy）**                 | 允许**动态切换算法**     | `setStrategy()`     | 运行时需要**切换算法**（如排序）        |
| **访问者（Visitor）**                 | 统一处理不同对象         | `accept(Visitor v)` | 需要**扩展对象操作**（如编译器 AST 遍历） |

🔹 **示例对比**

```java
// 🔹 责任链（请求传递）
class Handler {
    Handler next;

    void handle(Request r) {
        if (next != null) next.handle(r);
    }
}

// 🔹 命令（封装请求）
interface Command {
    void execute();
}

class LightOnCommand implements Command {
    public void execute() {
        System.out.println("Light On");
    }
}

// 🔹 观察者（监听事件）
class Subject {
    List<Observer> observers = new ArrayList<>();

    void notifyObservers() {
        for (Observer o : observers) o.update();
    }
}

// 🔹 策略（动态切换算法）
interface Strategy {
    void execute();
}

class QuickSort implements Strategy {
    public void execute() {
        System.out.println("QuickSort");
    }
}

class Context {
    Strategy strategy;

    void setStrategy(Strategy s) {
        strategy = s;
    }
}

// 🔹 访问者（访问不同对象）
interface Visitor {
    void visit(ElementA a);

    void visit(ElementB b);
}

class ConcreteVisitor implements Visitor {
    public void visit(ElementA a) {
        System.out.println("Visit A");
    }
}
```

---

## **🔥 记忆技巧**

- **创建型** = 解决对象**如何创建**
- **结构型** = 解决对象**如何组织**
- **行为型** = 解决对象**如何交互**

---
