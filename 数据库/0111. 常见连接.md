## 🧩 假设有两个表：

### 👨‍🎓 表 A（学生表）

| 学号（ID） | 姓名（Name） |
|--------|----------|
| 1      | 张三       |
| 2      | 李四       |
| 3      | 王五       |

### 📘 表 B（成绩表）

| 学号（ID） | 课程（Course） | 成绩（Score） |
|--------|------------|-----------|
| 1      | 数学         | 90        |
| 2      | 英语         | 85        |
| 4      | 物理         | 88        |

---

## 🔗 1. 自然连接（Natural Join）

**规则**：自动使用两个表中 **同名列（这里是ID）** 进行等值连接，只保留匹配成功的行。

```sql
SELECT * FROM A NATURAL JOIN B;
```

### 🔍 结果：

| ID | Name | Course | Score |
|----|------|--------|-------|
| 1  | 张三   | 数学     | 90    |
| 2  | 李四   | 英语     | 85    |

**说明**：
- 只保留了 A 和 B 中 `ID` 相同的记录。
- `ID=3`（王五）和 `ID=4`（物理成绩）都不在结果中，因为在另一个表中找不到匹配项。

### 📌 属性列说明：
- 只保留一份**公共列（同名列）**，其余列全部保留。
- 在本例中，`ID` 是公共列，因此只显示一列 `ID`，不会出现 `A.ID` 和 `B.ID` 各一份的情况。

✅ **连接后的属性列**：  
`ID`, `Name`, `Course`, `Score`

---

## 👈 2. 左外连接（Left Outer Join）

**规则**：保留左表（A）**全部记录**，如果右表（B）中没有匹配，则用 `NULL` 补齐。

```sql
SELECT * FROM A LEFT OUTER JOIN B ON A.ID = B.ID;
```

### 🔍 结果：

| ID | Name | Course | Score |
|----|------|--------|-------|
| 1  | 张三   | 数学     | 90    |
| 2  | 李四   | 英语     | 85    |
| 3  | 王五   | NULL   | NULL  |

**说明**：
- `王五` 没有对应成绩，但也显示出来了，`Course` 和 `Score` 用 `NULL` 填充。

### 📌 属性列说明：
- 保留左表所有列（A.ID, A.Name）
- 保留右表所有列（B.ID, B.Course, B.Score）

⚠️ 注意：如果两表有重名的列（如 ID），查询结果中会分别显示为 `A.ID`, `B.ID`（除非你用 `USING` 或 `NATURAL`）

✅ **连接后的属性列**（默认显示）：
`A.ID`, `Name`, `B.ID`, `Course`, `Score`  
（也可以用别名或只选 `A.ID`）

✅ 推荐显示的属性列（避免重复）：
`A.ID`, `Name`, `Course`, `Score`

---

## 👉 3. 右外连接（Right Outer Join）

**规则**：保留右表（B）**全部记录**，如果左表（A）中没有匹配，则用 `NULL` 补齐。

```sql
SELECT * FROM A RIGHT OUTER JOIN B ON A.ID = B.ID;
```

### 🔍 结果：

| ID | Name | Course | Score |
|----|------|--------|-------|
| 1  | 张三   | 数学     | 90    |
| 2  | 李四   | 英语     | 85    |
| 4  | NULL | 物理     | 88    |

**说明**：
- `物理成绩` 属于 `ID=4` 的学生，但学生表中没有这个人，用 `NULL` 补齐姓名。

### 📌 属性列说明：
- 保留右表所有列（B.ID, B.Course, B.Score）
- 保留左表所有列（A.ID, A.Name）

✅ **连接后的属性列**：
`A.ID`, `Name`, `B.ID`, `Course`, `Score`

✅ 推荐显示的属性列（去重）：
`B.ID`（或统一成 `ID`）, `Name`, `Course`, `Score`

---

## 🔄 4. 全外连接（Full Outer Join）

**规则**：保留两张表**所有记录**，没有匹配的用 `NULL` 填充。

> 注意：MySQL 不支持 `FULL OUTER JOIN`，但可以通过 `UNION` 实现。

```sql
SELECT * FROM A LEFT JOIN B ON A.ID = B.ID
UNION
SELECT * FROM A RIGHT JOIN B ON A.ID = B.ID;
```

### 🔍 结果：

| ID | Name | Course | Score |
|----|------|--------|-------|
| 1  | 张三   | 数学     | 90    |
| 2  | 李四   | 英语     | 85    |
| 3  | 王五   | NULL   | NULL  |
| 4  | NULL | 物理     | 88    |

**说明**：
- 所有人都显示了，不管有没有匹配，没匹配的列用 `NULL` 补全。

### 📌 属性列说明：
- 保留左右两表所有列
- 对于公共列（如 `ID`），若使用 `SELECT A.ID` 和 `B.ID`，会各保留一份

✅ **连接后的属性列（典型写法）**：
`ID`, `Name`, `Course`, `Score`  
（这里的 `ID` 是选择统一后的主键）

✅ 若两列都保留，结果会是：
`A.ID`, `B.ID`, `Name`, `Course`, `Score`  
→ 不推荐，容易混淆

---

## 🎯 总结对比表：

| 类型   | 保留左表 | 保留右表 | 只显示匹配 | 没有匹配时      |
|------|------|------|-------|------------|
| 自然连接 | ❌    | ❌    | ✅     | 丢弃         |
| 左外连接 | ✅    | ❌    | ✅     | 用 NULL 补右表 |
| 右外连接 | ❌    | ✅    | ✅     | 用 NULL 补左表 |
| 全外连接 | ✅    | ✅    | ✅     | 都补 NULL    |
