在数据库管理系统（DBMS）中，并发控制（Concurrency Control）是**确保多个事务同时执行时，数据的一致性和完整性**的一系列技术。由于多个事务可能会同时访问或修改相同的数据，合理的并发控制机制可以防止数据不一致问题，提高数据库的性能和可靠性。

---

## **1️⃣ 并发操作带来的问题**
当多个事务**同时**访问数据库时，可能会出现以下常见的并发问题：

### **❌ 幻读（Phantom Read）**
- **事务查询的结果在后续查询时，出现了新增或删除的记录**，但事务本身未进行修改。
- **解决方案**：一级封锁协议。

**示例**：
1. **T1** 读取 `SELECT COUNT(*) FROM orders WHERE price > 100`，结果为 `10` 条。
2. **T2** 插入一条 `price > 100` 的新订单并提交。
3. **T1** 再次执行相同的查询，结果变成 `11` 条（数据“幻影”出现）。

### **❌ 脏读（Dirty Read）**
- 事务 **T1** 修改了数据但**未提交**，事务 **T2** 读取了该数据。  
- 若 **T1 回滚**，则 **T2 读取的数据是错误的**。  
- **解决方案**：二级封锁协议。

**示例**：
1. **T1** 修改账户 A 余额 `1000 → 500`，但未提交。
2. **T2** 读取 A 余额 `500` 并执行某些操作。
3. **T1 回滚**，A 余额恢复 `1000`，导致 **T2 读到了错误数据**。


### **❌ 不可重复读（Non-repeatable Read）**
- **同一事务多次读取同一数据，但数据在两次读取之间被其他事务修改**，导致前后两次读取数据不一致。
- **解决方案**：三段封锁协议。

**示例**：
1. **T1** 读取 A 余额 `1000`。
2. **T2** 修改 A 余额 `1000 → 500` 并提交。
3. **T1** 再次读取 A 余额，发现变成 `500`（与前一次不一致）。


---

## **2️⃣ 共享锁（Shared Lock, S）和排他锁（Exclusive Lock, X）**
锁（Lock）是**控制并发访问**的主要机制，分为**共享锁（S）**和**排他锁（X）**。

### **🔹 共享锁（S，读锁）**
- 允许**多个事务**同时读取数据（**共享**）。
- **但不允许修改数据**。
- 适用于**查询操作**（`SELECT`）。

### **🔸 排他锁（X，写锁）**
- 事务**独占该资源**，其他事务不能进行**读或写**操作。
- 适用于**修改操作**（`INSERT`、`UPDATE`、`DELETE`）。

**共享锁与排他锁的兼容性：**

| **当前锁类型**  | **请求的锁类型** | **是否兼容** |
|------------|------------|----------|
| **共享锁（S）** | **共享锁（S）** | ✅ 兼容     |
| **共享锁（S）** | **排他锁（X）** | ❌ 不兼容    |
| **排他锁（X）** | **共享锁（S）** | ❌ 不兼容    |
| **排他锁（X）** | **排他锁（X）** | ❌ 不兼容    |

**示例**：
1. **T1** 申请 **S 锁**，**T2** 也可以申请 **S 锁**（同时读）。
2. **T1** 申请 **X 锁**，则 **T2** 不能申请任何锁（**T1 独占该数据**）。

---

## **3️⃣ 二段锁协议（Two-Phase Locking, 2PL）**
三段封锁协议是**解决并发问题的锁管理策略**，分为**两个阶段**：

### **📌 第一阶段：加锁阶段（Growing Phase）**
- 事务只能**申请锁**，不能释放锁。
- 事务**不断增加锁**，直到它获取了**所有需要的锁**。

### **📌 第二阶段：释放锁阶段（Shrinking Phase）**
- 事务只能**释放锁**，不能再申请新锁。
- 事务释放**第一个锁**后，就不能再申请任何锁。

### **📌 示例**
假设有 `T1` 和 `T2` 访问数据库：
1. **T1 加锁阶段**：
   - `T1` 申请 `X 锁` 以修改 A（成功）。
   - `T1` 申请 `X 锁` 以修改 B（成功）。
2. **T1 释放锁阶段**：
   - `T1` 释放 A 和 B 的 `X 锁`，结束事务。

3. **T2 等待 T1 释放锁**，然后执行自己的事务。

**优点**：
✅ 确保事务执行期间不会被破坏，避免 **脏读、不重复读、幻读**。  
❌ 可能会导致 **死锁（Deadlock）**，需要额外处理。

---

## **🔎 总结**
| **并发问题**  | **原因**         | **解决方案**   |
|-----------|----------------|------------|
| **幻读**    | 读数据后，新事务插入新数据  | **一级封锁协议** |
| **脏读**    | 读取未提交数据        | **二级封锁协议** |
| **不可重复读** | 读同一数据两次，第二次值变了 | **三级封锁协议** |
