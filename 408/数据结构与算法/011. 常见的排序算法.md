## 🌟 1. **直接插入排序（Insertion Sort）**  
👉 **思路：**  
- 把数组看成“已排序”和“未排序”两部分  
- 依次取出未排序部分的元素，插入到已排序部分的合适位置  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行直接插入排序  

| 步骤  | 过程         | 结果                |
|-----|------------|-------------------|
| 初始  | 原数组        | `[5, 3, 8, 6, 2]` |
| 第1步 | 将3插入到5前面   | `[3, 5, 8, 6, 2]` |
| 第2步 | 8不需要调整     | `[3, 5, 8, 6, 2]` |
| 第3步 | 将6插入到5和8之间 | `[3, 5, 6, 8, 2]` |
| 第4步 | 将2插入到最前面   | `[2, 3, 5, 6, 8]` |

✅ **特点：**  
- 稳定 ✅  
- 小规模数据效果好  

---

## 🌟 2. **冒泡排序（Bubble Sort）**  
👉 **思路：**  
- 每轮比较相邻两个元素  
- 发现逆序就交换，每轮把最大或最小的“冒”到一端  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行冒泡排序  

| 步骤  | 过程                | 结果                |
|-----|-------------------|-------------------|
| 初始  | 原数组               | `[5, 3, 8, 6, 2]` |
| 第1轮 | 交换5和3，交换8和6，交换6和2 | `[3, 5, 6, 2, 8]` |
| 第2轮 | 交换5和2             | `[3, 5, 2, 6, 8]` |
| 第3轮 | 交换5和2             | `[3, 2, 5, 6, 8]` |
| 第4轮 | 交换3和2             | `[2, 3, 5, 6, 8]` |

✅ **特点：**  
- 稳定 ✅  
- 简单但效率低  

---

## 🌟 3. **选择排序（Selection Sort）**  
👉 **思路：**  
- 每次在未排序区间中，选择最小或最大的元素，通过`交换`，放到有序区间  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行选择排序  

| 步骤  | 过程         | 结果                |
|-----|------------|-------------------|
| 初始  | 原数组        | `[5, 3, 8, 6, 2]` |
| 第1步 | 选择最小2放在第1位 | `[2, 3, 8, 6, 5]` |
| 第2步 | 选择最小3放在第2位 | `[2, 3, 8, 6, 5]` |
| 第3步 | 选择最小5放在第3位 | `[2, 3, 5, 6, 8]` |
| 第4步 | 已排序        | `[2, 3, 5, 6, 8]` |

❌ **特点：**  
- 不稳定 ❌  

---

## 🌟 4. **希尔排序（Shell Sort）**  
👉 **思路：**  
- 通过“分组 + 插入排序”实现  
- 先按较大间隔分组，逐步缩小间隔  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行希尔排序（步长 = 3, 1）  

| 步骤    | 结果                                        |
|-------|-------------------------------------------|
| 初始    | `[5, 3, 8, 6, 2]`                         |
| 按步长 2 | `[5, 6] [3, 2] [8]` → `[5, 6] [2, 3] [8]` |
| 按步长 1 | `[2, 3, 5, 6, 8]`                         |

❌ **特点：**  
- 不稳定 ❌  

---

## 🌟 5. **快速排序（Quick Sort）**  
👉 **思路：**  
- 选择一个基准数  
- 小于基准的放左边，大于基准的放右边  
- 递归执行  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 快速排序  

| 步骤  | 过程     | 结果                  |
|-----|--------|---------------------|
| 第1步 | 基准 = 5 | `[3, 2] [5] [8, 6]` |
| 第2步 | 左右递归   | `[2, 3] [5] [6, 8]` |
| 完成  | 合并     | `[2, 3, 5, 6, 8]`   |

❌ **特点：**  
- 不稳定 ❌  

---

## 🌟 6. **堆排序（Heap Sort）**  
👉 **思路：**  
- 建立最大堆或最小堆  
- 不断调整堆结构，取出堆顶元素  

### 🎯 **示例：**  
😎 **堆排序（Heap Sort）**的核心在于：  
1. **构建最大堆（或最小堆）** → 调整成堆结构  
2. **取出堆顶元素** → 交换到末尾  
3. **重新调整堆** → 继续构建最大堆  

---

## 🌳 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行堆排序  

---

### 🔥 **1. 原始数组 → 构建最大堆**  
**初始数组：**  
$$
[5, 3, 8, 6, 2]
$$

先将其表示成完全二叉树结构：  

```
    5
   / \
  3   8
 / \
6   2
```

### 🌟 调整成最大堆：  
- 从最后一个非叶子节点开始调整  
- 交换 3 和 6（因为左子节点 6 > 3） 
- 交换 5 和 8（因为右子节点 8 > 5）

```
    8
   / \
  6   5
 / \
3   2
```

---

### 🔥 **2. 取出堆顶元素（最大元素）**  
👉 将堆顶元素与最后一个元素交换，然后重新调整堆  

交换 `8 ↔ 2` 并删除最大元素（8）：  
```
    2
   / \
  6   5
 / \
3  
```

👉 调整堆结构（2和6交换）：  
```
    6
   / \
  2   5
 / \
3  
```

---

### 🔥 **3. 重复调整 → 排序完成**  
✅ 继续取堆顶，交换、调整，直到堆为空  

| 步骤            | 结果                |
|---------------|-------------------|
| 交换 6 ↔ 3 → 调整 | `5, 3, 2`         |
| 交换 5 ↔ 2 → 调整 | `3, 2`            |
| 交换 3 ↔ 2 → 调整 | `2`               |
| 最终排序结果        | `[2, 3, 5, 6, 8]` |

---

### ✅ **最终排序结果：**  
- 初始堆：  
```
    8
   / \
  6   5
 / \
3   2
```

- 调整 & 排序后：

| 步骤  | 结果                |
|-----|-------------------|
| 第1步 | `[2, 6, 5, 3, 8]` |
| 第2步 | `[2, 3, 5, 6, 8]` |
| 第3步 | `[2, 3, 5, 6, 8]` |
| 第4步 | `[2, 3, 5, 6, 8]` |

---

❌ **特点：**  
- 不稳定 ❌  

---

## 🌟 7. **归并排序（Merge Sort）**  
👉 **思路：**  
- 将数组不断二分  
- 排序后合并  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 归并排序  

| 步骤   | 结果                 |
|------|--------------------|
| 分裂   | `[5, 3] [8, 6, 2]` |
| 合并排序 | `[3, 5] [2, 6, 8]` |
| 合并   | `[2, 3, 5, 6, 8]`  |

✅ **特点：**  
- 稳定 ✅  

---

## 😎 **总结**：  

| 排序算法       | 时间复杂度（平均）       | 空间复杂度         | 稳定性   | 适用场景       |
|------------|-----------------|---------------|-------|------------|
| **直接插入排序** | $ O(n^2) $      | $ O(1) $      | ✅ 稳定  | 小规模数据，基本有序 |
| **冒泡排序**   | $ O(n^2) $      | $ O(1) $      | ✅ 稳定  | 小规模数据，基本有序 |
| **选择排序**   | $ O(n^2) $      | $ O(1) $      | ❌ 不稳定 | 小规模数据      |
| **希尔排序**   | $ O(n^{1.3}) $  | $ O(1) $      | ❌ 不稳定 | 中等规模数据     |
| **快速排序**   | $ O(n \log n) $ | $ O(\log n) $ | ❌ 不稳定 | 大规模数据      |
| **堆排序**    | $ O(n \log n) $ | $ O(1) $      | ❌ 不稳定 | 大规模数据      |
| **归并排序**   | $ O(n \log n) $ | $ O(n) $      | ✅ 稳定  | 大规模数据，外部排序 |

---