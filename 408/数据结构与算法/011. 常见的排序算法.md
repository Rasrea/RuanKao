## 🌟 1. **直接插入排序（Insertion Sort）**  
👉 **思路：**  
- 把数组看成“已排序”和“未排序”两部分  
- 依次取出未排序部分的元素，插入到已排序部分的合适位置  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行直接插入排序  

| 步骤  | 过程         | 结果                |
|-----|------------|-------------------|
| 初始  | 原数组        | `[5, 3, 8, 6, 2]` |
| 第1步 | 将3插入到5前面   | `[3, 5, 8, 6, 2]` |
| 第2步 | 8不需要调整     | `[3, 5, 8, 6, 2]` |
| 第3步 | 将6插入到5和8之间 | `[3, 5, 6, 8, 2]` |
| 第4步 | 将2插入到最前面   | `[2, 3, 5, 6, 8]` |

✅ **特点：**  
- 稳定 ✅  
- 小规模数据效果好  

---

## 🌟 2. **冒泡排序（Bubble Sort）**  
👉 **思路：**  
- 每轮比较相邻两个元素  
- 发现逆序就交换，每轮把最大或最小的“冒”到一端  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行冒泡排序  

| 步骤  | 过程                | 结果                |
|-----|-------------------|-------------------|
| 初始  | 原数组               | `[5, 3, 8, 6, 2]` |
| 第1轮 | 交换5和3，交换8和6，交换6和2 | `[3, 5, 6, 2, 8]` |
| 第2轮 | 交换5和2             | `[3, 5, 2, 6, 8]` |
| 第3轮 | 交换5和2             | `[3, 2, 5, 6, 8]` |
| 第4轮 | 交换3和2             | `[2, 3, 5, 6, 8]` |

✅ **特点：**  
- 稳定 ✅  
- 简单但效率低  

---

## 🌟 3. **选择排序（Selection Sort）**  
👉 **思路：**  
- 每次在未排序区间中，选择最小或最大的元素，通过`交换`，放到有序区间  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行选择排序  

| 步骤  | 过程         | 结果                |
|-----|------------|-------------------|
| 初始  | 原数组        | `[5, 3, 8, 6, 2]` |
| 第1步 | 选择最小2放在第1位 | `[2, 3, 8, 6, 5]` |
| 第2步 | 选择最小3放在第2位 | `[2, 3, 8, 6, 5]` |
| 第3步 | 选择最小5放在第3位 | `[2, 3, 5, 6, 8]` |
| 第4步 | 已排序        | `[2, 3, 5, 6, 8]` |

❌ **特点：**  
- 不稳定 ❌  

---

## 🌟 4. **希尔排序（Shell Sort）**  
👉 **思路：**  
- 通过“分组 + 插入排序”实现  
- 先按较大间隔分组，逐步缩小间隔  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行希尔排序（步长 = 3, 1）  

| 步骤    | 结果                                        |
|-------|-------------------------------------------|
| 初始    | `[5, 3, 8, 6, 2]`                         |
| 按步长 2 | `[5, 6] [3, 2] [8]` → `[5, 6] [2, 3] [8]` |
| 按步长 1 | `[2, 3, 5, 6, 8]`                         |

❌ **特点：**  
- 不稳定 ❌  

---

## 🌟 5. **快速排序（Quick Sort）**  
👉 **思路：**  
- 选择一个基准数  
- 左边找大于基准，右边找小于基准，交换位置
- 递归执行  

### 🎯 **示例：**  
对数组 `[3, 4, 6, 1, 2, 4, 7]` 以**第一个数**为基准  

| 步骤  | 结果                        |
|-----|---------------------------|
| 第1步 | `[2, 1] [3] [6, 4, 4, 7]` |
| 第2步 | `[1, 2] [3] [4, 4, 6, 7]` |
| 完成  | `[1, 2, 3, 4, 4, 6, 7]`   |

❌ **特点：**  
- 不稳定 ❌  

---

## 🌟 6. **堆排序（Heap Sort）**  
👉 **思路：**  
- 建立最大堆或最小堆  
- 不断调整堆结构，取出堆顶元素 
- **从下往上**排序

### 🎯 **示例：**  
😎 **堆排序（Heap Sort）** 的核心在于：  
1. **构建最大堆（或最小堆）** → 调整成堆结构  
2. **取出堆顶元素** → 交换到末尾  
3. **重新调整堆** → 继续构建最大堆  

---

## 🌳 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 进行堆排序  

---

### 🔥 **1. 原始数组 → 构建最大堆**  
**初始数组：** [5, 3, 8, 6, 2]

先将其表示成完全二叉树结构：  

```
    5
   / \
  3   8
 / \
6   2
```

### 🌟 调整成最大堆：  
- 从最后一个非叶子节点开始调整  
- 交换 3 和 6（因为左子节点 6 > 3） 
- 交换 5 和 8（因为右子节点 8 > 5）

```
    8
   / \
  6   5
 / \
3   2
```

---

### 🔥 **2. 取出堆顶元素（最大元素）**  
👉 将堆顶元素与最后一个元素交换，然后重新调整堆  

交换 `8 ↔ 2` 并删除最大元素（8）：  
```
    2
   / \
  6   5
 / \
3  
```

👉 调整堆结构（2和6交换）：  
```
    6
   / \
  2   5
 / \
3  
```

---

### 🔥 **3. 重复调整 → 排序完成**  
✅ 继续取堆顶，交换、调整，直到堆为空  

| 步骤            | 结果                |
|---------------|-------------------|
| 交换 6 ↔ 3 → 调整 | `5, 3, 2`         |
| 交换 5 ↔ 2 → 调整 | `3, 2`            |
| 交换 3 ↔ 2 → 调整 | `2`               |
| 最终排序结果        | `[2, 3, 5, 6, 8]` |

---

### ✅ **最终排序结果：**  
- 初始堆：  
```
    8
   / \
  6   5
 / \
3   2
```

- 调整 & 排序后：

| 步骤  | 结果                |
|-----|-------------------|
| 第1步 | `[2, 6, 5, 3, 8]` |
| 第2步 | `[2, 3, 5, 6, 8]` |
| 第3步 | `[2, 3, 5, 6, 8]` |
| 第4步 | `[2, 3, 5, 6, 8]` |

---

❌ **特点：**  
- 不稳定 ❌  

---

## 🌟 7. **归并排序（Merge Sort）**  
👉 **思路：**  
- 将数组不断二分  
- 排序后合并  

### 🎯 **示例：**  
对数组 `[5, 3, 8, 6, 2]` 归并排序  

| 步骤   | 结果                 |
|------|--------------------|
| 分裂   | `[5, 3] [8, 6, 2]` |
| 合并排序 | `[3, 5] [2, 6, 8]` |
| 合并   | `[2, 3, 5, 6, 8]`  |

✅ **特点：**  
- 稳定 ✅  

## 🌟 8. 什么是排序算法的稳定性？

📌 **定义**：  
若在排序前，两个关键字相同的元素，排序后**相对位置不变**，则该排序算法是**稳定的**。

👉 举个例子：

原数组（按照年龄排序）：

```
[张三(25岁), 李四(20岁), 王五(25岁)]
```

- 张三和王五的关键字（25）相同，张三在前。
- 排序后如果仍然保持 **张三在王五前**，就是稳定的。

---

## 😎 **总结**：  

| 排序算法       | 最优时间复杂度       | 平均时间复杂度       | 最差时间复杂度       | 空间复杂度           | 稳定性   | 适用场景       |
|------------|---------------|---------------|---------------|-----------------|-------|------------|
| **直接插入排序** | $O(n)$        | $O(n^2)$      | $O(n^2)$      | $O(1)$          | ✅ 稳定  | 小规模数据，基本有序 |
| **冒泡排序**   | $O(n)$        | $O(n^2)$      | $O(n^2)$      | $O(1)$          | ✅ 稳定  | 小规模数据，基本有序 |
| **选择排序**   | $O(n^2)$      | $O(n^2)$      | $O(n^2)$      | $O(1)$          | ❌ 不稳定 | 小规模数据      |
| **希尔排序**   | $O(n \log n)$ | $O(n^{1.3})$  | $O(n^2)$      | $O(1)$          | ❌ 不稳定 | 中等规模数据     |
| **快速排序**   | $O(n \log n)$ | $O(n \log n)$ | $O(n^2)$      | $O(\log n)$（递归） | ❌ 不稳定 | 大规模数据，无序   |
| **堆排序**    | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(1)$          | ❌ 不稳定 | 大规模数据      |
| **归并排序**   | $O(n \log n)$ | $O(n \log n)$ | $O(n \log n)$ | $O(n)$          | ✅ 稳定  | 大规模数据，外部排序 |
---