### 区分 `贪心（Greedy）、回溯（Backtracking）、动态规划（Dynamic Programming, DP）、分治（Divide and Conquer）` 四种算法

---

## **1️⃣ 贪心算法（Greedy Algorithm）—— 每一步都选最优**
**核心思想** 🧠：
- **每一步** 都做出当前最优（局部最优）选择，不考虑全局，期望最终结果也是最优（全局最优）。
- **适用于“贪心选择性质”的问题**，即后面的决策不会影响前面已做出的决策。

**特点**：
✅ 速度快，通常是 **O(n) 或 O(n log n)** 级别。  
❌ 不能保证最优解，适用于特定问题。  

**示例：找零问题（最少硬币）**
- 假设有面额 `{1, 5, 10, 50, 100}` 的硬币，要找 `126` 元，如何找最少的硬币？
- **贪心策略**：每次选择最大面额的硬币。
  - 选 `100`，还剩 `26`
  - 选 `10`，还剩 `16`
  - 选 `10`，还剩 `6`
  - 选 `5`，还剩 `1`
  - 选 `1`
- 共 `5` 枚硬币 ✅，但如果硬币种类不同（如 `{1, 4, 6}`），贪心可能不是最优解 ❌。

---

## **2️⃣ 回溯算法（Backtracking）—— 尝试 & 回头**
**核心思想** 🧠：
- **暴力搜索 + 剪枝优化**，尝试所有可能的路径，遇到不行的路就**回溯**（撤销上一步）。
- 适用于 **所有情况都要穷举** 的问题，如排列组合、数独、迷宫、八皇后等。

**特点**：
✅ 能找到**所有可能的解**，适合搜索问题。  
❌ 速度慢，可能达到 **O(2^n) 指数级**，需要优化（如剪枝）。  

**示例：八皇后问题**
- 在 `8x8` 棋盘上放置 `8` 个皇后，使得它们**互相不能攻击**。
- **回溯做法**：
  1. 从第一行开始，尝试在每一列放置皇后。
  2. 放下后，检查是否与前面的皇后冲突（同行、同列、对角线）。
  3. 如果冲突，则**回溯**，撤回上一次的决定，换一个位置再试。
  4. 直到找到所有可行解。

---

## **3️⃣ 动态规划（Dynamic Programming, DP）—— 记录子问题**
**核心思想** 🧠：
- **拆分问题 → 解决子问题 → 记录子问题的解 → 组合子问题得到最终解**。
- **适用于“最优子结构”+“重叠子问题”** 的问题。
- 经典应用：**斐波那契数列、最长公共子序列（LCS）、背包问题**。

**特点**：
✅ 比回溯更快，通常是 **O(n^2)**。  
✅ 适用于问题可以**拆分成子问题**，并且**子问题的解可以复用**的情况。  
❌ 代码实现较复杂，**需要设计状态转移方程**。

---

## **4️⃣ 分治算法（Divide and Conquer）—— 拆分 + 递归解决 + 合并**
**核心思想** 🧠：
- 将大问题拆分成多个**小问题**，分别求解后，再**合并**结果。
- 适用于**可以递归分解**的问题，如**归并排序、快速排序、二分查找**等。

**特点**：
✅ 递归方式，通常时间复杂度 **O(n log n)**。  
✅ 适用于可以**分解为相似子问题**并且**合并结果**的问题。  
❌ 代码实现有时候较复杂，可能会有额外的**递归开销**。  

**示例：归并排序（Merge Sort）**
- **分解**：将数组一分为二，递归地继续拆分。
- **解决**：对每个子数组排序。
- **合并**：将两个排好序的子数组合并。
- **例子**：折半查找。

---

## **总结 🎯**
| 算法          | 核心思想         | 适用场景                                       | 优缺点          |
|-------------|--------------|--------------------------------------------|--------------|
| **贪心** 🤔   | 每次选择当前最优     | 适用于**局部最优能保证全局最优**的情况，如活动安排、最短路径（Dijkstra） | 速度快，但不一定全局最优 |
| **回溯** 🔄   | 穷举所有可能，失败就回头 | 适用于**所有可能性都要尝试**的情况，如数独、八皇后、全排列            | 可以找到所有解，但慢   |
| **动态规划** 📊 | 拆分子问题，记录最优解  | 适用于**子问题重复出现**的问题，如背包、LCS                  | 速度比回溯快，代码复杂  |
| **分治** ✂️   | 拆分问题，合并结果    | 适用于**可以递归分解**的问题，如归并排序、二分查找                | 递归实现，可能有开销   |

你可以这样记住：
- **贪心 = 只看当前最优**，不回头
- **回溯 = 尝试 & 失败就撤回**
- **动态规划 = 记录之前的解，避免重复计算**
- **分治 = 拆分成多个小问题，递归解决**

