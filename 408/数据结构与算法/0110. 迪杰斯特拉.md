**Dijkstra（迪杰斯特拉）算法** 是用于解决**单源最短路径**问题的经典算法之一，适用于**加权图中所有边权值为非负数**的情况。它可以求出某个起点到图中其他所有顶点的最短路径。

---

## 🧠 一、算法基本思想

从起点出发，不断选择当前**距离起点最近**的未访问节点，并以它为中心更新其他节点的最短路径。

### ✅ 特点：

* 只能用于**边权非负**的图。
* 本质是 **贪心算法**。
* 可以处理有向图和无向图。

---

## 🔁 二、基本步骤（伪代码风格）

1. 初始化起点距离为 0，其它点为 ∞。
2. 选一个未访问的、当前距离最小的点 `u`。
3. 遍历 `u` 的邻居 `v`：

   * 如果 `dist[u] + weight(u,v) < dist[v]`，就更新 `dist[v]`。
4. 重复步骤 2 和 3，直到所有点都被访问。

---

## 📦 三、例子

给出如下图（有向图）：

```
    A
  / | \
1  4  2
/   |   \
B   C    D
 \     /
  \---/
    3
```

边权为：

* A→B: 1
* A→C: 4
* A→D: 2
* B→D: 3

我们求 A 到其他点的最短路径。

| 终点   | 1            | 2            | 前驱节点（prev）   |
|------|--------------|--------------|--------------|
| A    | 0            | -            | -            |
| B    | 1<br/>(A, B) | -            | -            |
| C    | 4<br/>(A, C) | 4<br/>(A, C) | 4<br/>(A, C) |
| D    | 2<br/>(A, D) | 2<br/>(A, D) | -            |
| 集合 S | (A, B)       | (A, B, D)    | (A, B, D, C) |

---

## 🔢 时间复杂度：

* 使用**朴素数组**：`O(n^2)`
* 使用**堆（优先队列）+ 邻接表**：`O(mlogn)`，`m` 为边数

---

## ❗注意：
> 考试时请相信自己的直觉，选择题不要浪费时间。

---
